/* generated by OpenModelica */
#ifndef OpenModelicaScriptingAPIQt__H
#define OpenModelicaScriptingAPIQt__H

#include <stdexcept>
#include "OpenModelicaScriptingAPIQt.h"

OMCInterface::OMCInterface(threadData_t *td)
  : threadData(td)
{
}
OMCInterface::generateScriptingAPI_res OMCInterface::generateScriptingAPI(QString cl, QString name)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  commandLog.append(",");
  commandLog.append("\"" + name + "\"");
  emit logCommand("generateScriptingAPI("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QByteArray name_utf8 = name.toUtf8();
  generateScriptingAPI_res result;
  void *out2_mm = NULL;
  void *out3_mm = NULL;
  void *out4_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result.success = omc_OpenModelicaScriptingAPI_generateScriptingAPI(threadData, mmc_mk_scon(cl_utf8.data()), mmc_mk_scon(name_utf8.data()), &out2_mm, &out3_mm, &out4_mm);
    result.moFile = QString::fromUtf8(MMC_STRINGDATA(out2_mm));
    result.qtFile = QString::fromUtf8(MMC_STRINGDATA(out3_mm));
    result.qtHeader = QString::fromUtf8(MMC_STRINGDATA(out4_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("generateScriptingAPI failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("generateScriptingAPI("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::deleteInitialState(QString cl, QString state)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  commandLog.append(",");
  commandLog.append("\"" + state + "\"");
  emit logCommand("deleteInitialState("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QByteArray state_utf8 = state.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_deleteInitialState(threadData, mmc_mk_scon(cl_utf8.data()), mmc_mk_scon(state_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("deleteInitialState failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("deleteInitialState("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QList<QString > > OMCInterface::getInitialStates(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("getInitialStates("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QList<QList<QString > > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getInitialStates(threadData, mmc_mk_scon(cl_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QList<QString > result_elt;
      result_elt.clear();
      while (!listEmpty(MMC_CAR(result_mm))) {
        QString result_elt_elt;
        result_elt_elt = MMC_STRINGDATA(MMC_CAR(MMC_CAR(result_mm)));
        result_elt.push_back(result_elt_elt);
        MMC_CAR(result_mm) = MMC_CDR(MMC_CAR(result_mm));
      }
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getInitialStates failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QList<QString > result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("{");
    int result_elt_i = 0;
    foreach(QString result_elt_elt, result_elt) {
      if (result_elt_i) {
        responseLog.append(",");
      }
      responseLog.append("\"" + result_elt_elt + "\"");
      result_elt_i++;
    }
    responseLog.append("}");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getInitialStates("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::deleteTransition(QString cl, QString from, QString to, QString condition, modelica_boolean immediate, modelica_boolean reset, modelica_boolean synchronize, modelica_integer priority)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  commandLog.append(",");
  commandLog.append("\"" + from + "\"");
  commandLog.append(",");
  commandLog.append("\"" + to + "\"");
  commandLog.append(",");
  commandLog.append("\"" + condition + "\"");
  commandLog.append(",");
  commandLog.append(immediate ? "true" : "false");
  commandLog.append(",");
  commandLog.append(reset ? "true" : "false");
  commandLog.append(",");
  commandLog.append(synchronize ? "true" : "false");
  commandLog.append(",");
  commandLog.append(QString::number(priority));
  emit logCommand("deleteTransition("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QByteArray from_utf8 = from.toUtf8();
  QByteArray to_utf8 = to.toUtf8();
  QByteArray condition_utf8 = condition.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_deleteTransition(threadData, mmc_mk_scon(cl_utf8.data()), mmc_mk_scon(from_utf8.data()), mmc_mk_scon(to_utf8.data()), mmc_mk_scon(condition_utf8.data()), immediate, reset, synchronize, priority);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("deleteTransition failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("deleteTransition("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QList<QString > > OMCInterface::getTransitions(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("getTransitions("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QList<QList<QString > > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getTransitions(threadData, mmc_mk_scon(cl_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QList<QString > result_elt;
      result_elt.clear();
      while (!listEmpty(MMC_CAR(result_mm))) {
        QString result_elt_elt;
        result_elt_elt = MMC_STRINGDATA(MMC_CAR(MMC_CAR(result_mm)));
        result_elt.push_back(result_elt_elt);
        MMC_CAR(result_mm) = MMC_CDR(MMC_CAR(result_mm));
      }
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getTransitions failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QList<QString > result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("{");
    int result_elt_i = 0;
    foreach(QString result_elt_elt, result_elt) {
      if (result_elt_i) {
        responseLog.append(",");
      }
      responseLog.append("\"" + result_elt_elt + "\"");
      result_elt_i++;
    }
    responseLog.append("}");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getTransitions("+commandLog+")", responseLog, &commandTime);

  return result;
}
OMCInterface::getClassInformation_res OMCInterface::getClassInformation(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("getClassInformation("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  getClassInformation_res result;
  void *out1_mm = NULL;
  void *out2_mm = NULL;
  void *out6_mm = NULL;
  void *out12_mm = NULL;
  void *out15_mm = NULL;
  void *out16_mm = NULL;
  void *out18_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    out1_mm = omc_OpenModelicaScriptingAPI_getClassInformation(threadData, mmc_mk_scon(cl_utf8.data()), &out2_mm, &result.partialPrefix, &result.finalPrefix, &result.encapsulatedPrefix, &out6_mm, &result.fileReadOnly, &result.lineNumberStart, &result.columnNumberStart, &result.lineNumberEnd, &result.columnNumberEnd, &out12_mm, &result.isProtectedClass, &result.isDocumentationClass, &out15_mm, &out16_mm, &result.state, &out18_mm);
    result.restriction = QString::fromUtf8(MMC_STRINGDATA(out1_mm));
    result.comment = QString::fromUtf8(MMC_STRINGDATA(out2_mm));
    result.fileName = QString::fromUtf8(MMC_STRINGDATA(out6_mm));
    result.dimensions.clear();
    while (!listEmpty(out12_mm)) {
      QString out12_elt;
      out12_elt = MMC_STRINGDATA(MMC_CAR(out12_mm));
      result.dimensions.push_back(out12_elt);
      out12_mm = MMC_CDR(out12_mm);
    }
    result.version = QString::fromUtf8(MMC_STRINGDATA(out15_mm));
    result.preferredView = QString::fromUtf8(MMC_STRINGDATA(out16_mm));
    result.access = QString::fromUtf8(MMC_STRINGDATA(out18_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getClassInformation failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("getClassInformation("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::sortStrings(QList<QString > arr)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("{");
  int arr_i = 0;
  foreach(QString arr_elt, arr) {
    if (arr_i) {
      commandLog.append(",");
    }
    commandLog.append("\"" + arr_elt + "\"");
    arr_i++;
  }
  commandLog.append("}");
  emit logCommand("sortStrings("+commandLog+")", &commandTime);

  void *arr_lst = mmc_mk_nil();
  for (int arr_i = arr.size()-1; arr_i>=0; arr_i--) {
    QString arr_elt = arr[arr_i];
    QByteArray arr_elt_utf8 = arr_elt.toUtf8();
    arr_lst = mmc_mk_cons(mmc_mk_scon(arr_elt_utf8.data()), arr_lst);
  }
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_sortStrings(threadData, arr_lst);
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("sortStrings failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("sortStrings("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::checkInterfaceOfPackages(QString cl, QList<QList<QString > > dependencyMatrix)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  commandLog.append(",");
  commandLog.append("{");
  int dependencyMatrix_i = 0;
  foreach(QList<QString > dependencyMatrix_elt, dependencyMatrix) {
    if (dependencyMatrix_i) {
      commandLog.append(",");
    }
    commandLog.append("{");
    int dependencyMatrix_elt_i = 0;
    foreach(QString dependencyMatrix_elt_elt, dependencyMatrix_elt) {
      if (dependencyMatrix_elt_i) {
        commandLog.append(",");
      }
      commandLog.append("\"" + dependencyMatrix_elt_elt + "\"");
      dependencyMatrix_elt_i++;
    }
    commandLog.append("}");
    dependencyMatrix_i++;
  }
  commandLog.append("}");
  emit logCommand("checkInterfaceOfPackages("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  void *dependencyMatrix_lst = mmc_mk_nil();
  for (int dependencyMatrix_i = dependencyMatrix.size()-1; dependencyMatrix_i>=0; dependencyMatrix_i--) {
    QList<QString > dependencyMatrix_elt = dependencyMatrix[dependencyMatrix_i];
    void *dependencyMatrix_elt_lst = mmc_mk_nil();
    for (int dependencyMatrix_elt_i = dependencyMatrix_elt.size()-1; dependencyMatrix_elt_i>=0; dependencyMatrix_elt_i--) {
      QString dependencyMatrix_elt_elt = dependencyMatrix_elt[dependencyMatrix_elt_i];
      QByteArray dependencyMatrix_elt_elt_utf8 = dependencyMatrix_elt_elt.toUtf8();
      dependencyMatrix_elt_lst = mmc_mk_cons(mmc_mk_scon(dependencyMatrix_elt_elt_utf8.data()), dependencyMatrix_elt_lst);
    }
    dependencyMatrix_lst = mmc_mk_cons(dependencyMatrix_elt_lst, dependencyMatrix_lst);
  }
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_checkInterfaceOfPackages(threadData, mmc_mk_scon(cl_utf8.data()), dependencyMatrix_lst);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("checkInterfaceOfPackages failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("checkInterfaceOfPackages("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::GC_set_max_heap_size(modelica_integer size)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(QString::number(size));
  emit logCommand("GC__set__max__heap__size("+commandLog+")", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_GC__set__max__heap__size(threadData, size);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("GC__set__max__heap__size failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("GC__set__max__heap__size("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::GC_expand_hp(modelica_integer size)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(QString::number(size));
  emit logCommand("GC__expand__hp("+commandLog+")", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_GC__expand__hp(threadData, size);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("GC__expand__hp failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("GC__expand__hp("+commandLog+")", responseLog, &commandTime);

  return result;
}
void OMCInterface::GC_gcollect_and_unmap()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("GC__gcollect__and__unmap()", &commandTime);

  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    omc_OpenModelicaScriptingAPI_GC__gcollect__and__unmap(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("GC__gcollect__and__unmap failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  emit logResponse("GC__gcollect__and__unmap()", responseLog, &commandTime);

}
modelica_real OMCInterface::getMemorySize()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getMemorySize()", &commandTime);

  modelica_real result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getMemorySize(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getMemorySize failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getMemorySize()", responseLog, &commandTime);

  return result;
}
void OMCInterface::threadWorkFailed()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("threadWorkFailed()", &commandTime);

  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    omc_OpenModelicaScriptingAPI_threadWorkFailed(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("threadWorkFailed failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  emit logResponse("threadWorkFailed()", responseLog, &commandTime);

}
void OMCInterface::exit(modelica_integer status)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(QString::number(status));
  emit logCommand("exit("+commandLog+")", &commandTime);

  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    omc_OpenModelicaScriptingAPI_exit(threadData, status);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("exit failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  emit logResponse("exit("+commandLog+")", responseLog, &commandTime);

}
QList<modelica_boolean > OMCInterface::runScriptParallel(QList<QString > scripts, modelica_integer numThreads, modelica_boolean useThreads)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("{");
  int scripts_i = 0;
  foreach(QString scripts_elt, scripts) {
    if (scripts_i) {
      commandLog.append(",");
    }
    commandLog.append("\"" + scripts_elt + "\"");
    scripts_i++;
  }
  commandLog.append("}");commandLog.append(",");
  commandLog.append(QString::number(numThreads));
  commandLog.append(",");
  commandLog.append(useThreads ? "true" : "false");
  emit logCommand("runScriptParallel("+commandLog+")", &commandTime);

  void *scripts_lst = mmc_mk_nil();
  for (int scripts_i = scripts.size()-1; scripts_i>=0; scripts_i--) {
    QString scripts_elt = scripts[scripts_i];
    QByteArray scripts_elt_utf8 = scripts_elt.toUtf8();
    scripts_lst = mmc_mk_cons(mmc_mk_scon(scripts_elt_utf8.data()), scripts_lst);
  }
  QList<modelica_boolean > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_runScriptParallel(threadData, scripts_lst, numThreads, useThreads);
    result.clear();
    while (!listEmpty(result_mm)) {
      modelica_boolean result_elt;
      result_elt = mmc_unbox_boolean(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("runScriptParallel failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(modelica_boolean result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt ? "true" : "false");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("runScriptParallel("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::numProcessors()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("numProcessors()", &commandTime);

  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_numProcessors(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("numProcessors failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("numProcessors()", responseLog, &commandTime);

  return result;
}
void OMCInterface::generateEntryPoint(QString fileName, QString entryPoint, QString url)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  commandLog.append(",");
  commandLog.append(entryPoint);
  commandLog.append(",");
  commandLog.append("\"" + url + "\"");
  emit logCommand("generateEntryPoint("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QByteArray entryPoint_utf8 = entryPoint.toUtf8();
  QByteArray url_utf8 = url.toUtf8();
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    omc_OpenModelicaScriptingAPI_generateEntryPoint(threadData, mmc_mk_scon(fileName_utf8.data()), mmc_mk_scon(entryPoint_utf8.data()), mmc_mk_scon(url_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("generateEntryPoint failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  emit logResponse("generateEntryPoint("+commandLog+")", responseLog, &commandTime);

}
QString OMCInterface::getDerivedClassModifierValue(QString className, QString modifierName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(modifierName);
  emit logCommand("getDerivedClassModifierValue("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray modifierName_utf8 = modifierName.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getDerivedClassModifierValue(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(modifierName_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getDerivedClassModifierValue failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getDerivedClassModifierValue("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getDerivedClassModifierNames(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("getDerivedClassModifierNames("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getDerivedClassModifierNames(threadData, mmc_mk_scon(className_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getDerivedClassModifierNames failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getDerivedClassModifierNames("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QList<QString > > OMCInterface::getUses(QString pack)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(pack);
  emit logCommand("getUses("+commandLog+")", &commandTime);

  QByteArray pack_utf8 = pack.toUtf8();
  QList<QList<QString > > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getUses(threadData, mmc_mk_scon(pack_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QList<QString > result_elt;
      result_elt.clear();
      while (!listEmpty(MMC_CAR(result_mm))) {
        QString result_elt_elt;
        result_elt_elt = MMC_STRINGDATA(MMC_CAR(MMC_CAR(result_mm)));
        result_elt.push_back(result_elt_elt);
        MMC_CAR(result_mm) = MMC_CDR(MMC_CAR(result_mm));
      }
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getUses failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QList<QString > result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("{");
    int result_elt_i = 0;
    foreach(QString result_elt_elt, result_elt) {
      if (result_elt_i) {
        responseLog.append(",");
      }
      responseLog.append("\"" + result_elt_elt + "\"");
      result_elt_i++;
    }
    responseLog.append("}");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getUses("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getAvailableLibraries()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getAvailableLibraries()", &commandTime);

  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getAvailableLibraries(threadData);
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAvailableLibraries failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getAvailableLibraries()", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::searchClassNames(QString searchText, modelica_boolean findInText)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + searchText + "\"");
  commandLog.append(",");
  commandLog.append(findInText ? "true" : "false");
  emit logCommand("searchClassNames("+commandLog+")", &commandTime);

  QByteArray searchText_utf8 = searchText.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_searchClassNames(threadData, mmc_mk_scon(searchText_utf8.data()), findInText);
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("searchClassNames failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt);
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("searchClassNames("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::extendsFrom(QString className, QString baseClassName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(baseClassName);
  emit logCommand("extendsFrom("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray baseClassName_utf8 = baseClassName.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_extendsFrom(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(baseClassName_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("extendsFrom failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("extendsFrom("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::getBooleanClassAnnotation(QString className, QString annotationName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(annotationName);
  emit logCommand("getBooleanClassAnnotation("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray annotationName_utf8 = annotationName.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getBooleanClassAnnotation(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(annotationName_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getBooleanClassAnnotation failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("getBooleanClassAnnotation("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::classAnnotationExists(QString className, QString annotationName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(annotationName);
  emit logCommand("classAnnotationExists("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray annotationName_utf8 = annotationName.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_classAnnotationExists(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(annotationName_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("classAnnotationExists failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("classAnnotationExists("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getAnnotationModifierValue(QString name, QString vendorannotation, QString modifiername)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(name);
  commandLog.append(",");
  commandLog.append("\"" + vendorannotation + "\"");
  commandLog.append(",");
  commandLog.append("\"" + modifiername + "\"");
  emit logCommand("getAnnotationModifierValue("+commandLog+")", &commandTime);

  QByteArray name_utf8 = name.toUtf8();
  QByteArray vendorannotation_utf8 = vendorannotation.toUtf8();
  QByteArray modifiername_utf8 = modifiername.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getAnnotationModifierValue(threadData, mmc_mk_scon(name_utf8.data()), mmc_mk_scon(vendorannotation_utf8.data()), mmc_mk_scon(modifiername_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAnnotationModifierValue failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getAnnotationModifierValue("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getAnnotationNamedModifiers(QString name, QString vendorannotation)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(name);
  commandLog.append(",");
  commandLog.append("\"" + vendorannotation + "\"");
  emit logCommand("getAnnotationNamedModifiers("+commandLog+")", &commandTime);

  QByteArray name_utf8 = name.toUtf8();
  QByteArray vendorannotation_utf8 = vendorannotation.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getAnnotationNamedModifiers(threadData, mmc_mk_scon(name_utf8.data()), mmc_mk_scon(vendorannotation_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAnnotationNamedModifiers failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getAnnotationNamedModifiers("+commandLog+")", responseLog, &commandTime);

  return result;
}
OMCInterface::getSimulationOptions_res OMCInterface::getSimulationOptions(QString name, modelica_real defaultStartTime, modelica_real defaultStopTime, modelica_real defaultTolerance, modelica_integer defaultNumberOfIntervals, modelica_real defaultInterval)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(name);
  commandLog.append(",");
  commandLog.append(QString::number(defaultStartTime));
  commandLog.append(",");
  commandLog.append(QString::number(defaultStopTime));
  commandLog.append(",");
  commandLog.append(QString::number(defaultTolerance));
  commandLog.append(",");
  commandLog.append(QString::number(defaultNumberOfIntervals));
  commandLog.append(",");
  commandLog.append(QString::number(defaultInterval));
  emit logCommand("getSimulationOptions("+commandLog+")", &commandTime);

  QByteArray name_utf8 = name.toUtf8();
  getSimulationOptions_res result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result.startTime = omc_OpenModelicaScriptingAPI_getSimulationOptions(threadData, mmc_mk_scon(name_utf8.data()), defaultStartTime, defaultStopTime, defaultTolerance, defaultNumberOfIntervals, defaultInterval, &result.stopTime, &result.tolerance, &result.numberOfIntervals, &result.interval);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getSimulationOptions failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("getSimulationOptions("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isExperiment(QString name)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(name);
  emit logCommand("isExperiment("+commandLog+")", &commandTime);

  QByteArray name_utf8 = name.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isExperiment(threadData, mmc_mk_scon(name_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isExperiment failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isExperiment("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getInheritedClasses(QString name)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(name);
  emit logCommand("getInheritedClasses("+commandLog+")", &commandTime);

  QByteArray name_utf8 = name.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getInheritedClasses(threadData, mmc_mk_scon(name_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getInheritedClasses failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt);
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getInheritedClasses("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getBuiltinType(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("getBuiltinType("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getBuiltinType(threadData, mmc_mk_scon(cl_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getBuiltinType failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getBuiltinType("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isProtectedClass(QString cl, QString c2)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  commandLog.append(",");
  commandLog.append("\"" + c2 + "\"");
  emit logCommand("isProtectedClass("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QByteArray c2_utf8 = c2.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isProtectedClass(threadData, mmc_mk_scon(cl_utf8.data()), mmc_mk_scon(c2_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isProtectedClass failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isProtectedClass("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isOperatorFunction(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isOperatorFunction("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isOperatorFunction(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isOperatorFunction failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isOperatorFunction("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isOperatorRecord(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isOperatorRecord("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isOperatorRecord(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isOperatorRecord failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isOperatorRecord("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isOperator(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isOperator("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isOperator(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isOperator failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isOperator("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isEnumeration(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isEnumeration("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isEnumeration(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isEnumeration failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isEnumeration("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isOptimization(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isOptimization("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isOptimization(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isOptimization failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isOptimization("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isConnector(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isConnector("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isConnector(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isConnector failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isConnector("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isModel(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isModel("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isModel(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isModel failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isModel("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isPartial(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isPartial("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isPartial(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isPartial failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isPartial("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isFunction(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isFunction("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isFunction(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isFunction failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isFunction("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isBlock(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isBlock("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isBlock(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isBlock failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isBlock("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isRecord(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isRecord("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isRecord(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isRecord failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isRecord("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isClass(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isClass("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isClass(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isClass failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isClass("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isPackage(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isPackage("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isPackage(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isPackage failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isPackage("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isType(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("isType("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isType(threadData, mmc_mk_scon(cl_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isType failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isType("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getClassRestriction(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("getClassRestriction("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getClassRestriction(threadData, mmc_mk_scon(cl_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getClassRestriction failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getClassRestriction("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::basename(QString path)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + path + "\"");
  emit logCommand("basename("+commandLog+")", &commandTime);

  QByteArray path_utf8 = path.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_basename(threadData, mmc_mk_scon(path_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("basename failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("basename("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::dirname(QString path)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + path + "\"");
  emit logCommand("dirname("+commandLog+")", &commandTime);

  QByteArray path_utf8 = path.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_dirname(threadData, mmc_mk_scon(path_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("dirname failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("dirname("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getClassComment(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("getClassComment("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getClassComment(threadData, mmc_mk_scon(cl_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getClassComment failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getClassComment("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::typeNameStrings(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("typeNameStrings("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_typeNameStrings(threadData, mmc_mk_scon(cl_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("typeNameStrings failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("typeNameStrings("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::typeNameString(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("typeNameString("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_typeNameString(threadData, mmc_mk_scon(cl_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("typeNameString failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("typeNameString("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::stringTypeName(QString str)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + str + "\"");
  emit logCommand("stringTypeName("+commandLog+")", &commandTime);

  QByteArray str_utf8 = str.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_stringTypeName(threadData, mmc_mk_scon(str_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("stringTypeName failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result);
  emit logResponse("stringTypeName("+commandLog+")", responseLog, &commandTime);

  return result;
}
OMCInterface::getTimeStamp_res OMCInterface::getTimeStamp(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("getTimeStamp("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  getTimeStamp_res result;
  void *out2_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result.timeStamp = omc_OpenModelicaScriptingAPI_getTimeStamp(threadData, mmc_mk_scon(cl_utf8.data()), &out2_mm);
    result.timeStampAsString = QString::fromUtf8(MMC_STRINGDATA(out2_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getTimeStamp failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("getTimeStamp("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setDocumentationAnnotation(QString class_, QString info, QString revisions)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append("\"" + info + "\"");
  commandLog.append(",");
  commandLog.append("\"" + revisions + "\"");
  emit logCommand("setDocumentationAnnotation("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QByteArray info_utf8 = info.toUtf8();
  QByteArray revisions_utf8 = revisions.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setDocumentationAnnotation(threadData, mmc_mk_scon(class__utf8.data()), mmc_mk_scon(info_utf8.data()), mmc_mk_scon(revisions_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setDocumentationAnnotation failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setDocumentationAnnotation("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getDocumentationAnnotation(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("getDocumentationAnnotation("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getDocumentationAnnotation(threadData, mmc_mk_scon(cl_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getDocumentationAnnotation failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getDocumentationAnnotation("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::iconv(QString string, QString from, QString to)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + string + "\"");
  commandLog.append(",");
  commandLog.append("\"" + from + "\"");
  commandLog.append(",");
  commandLog.append("\"" + to + "\"");
  emit logCommand("iconv("+commandLog+")", &commandTime);

  QByteArray string_utf8 = string.toUtf8();
  QByteArray from_utf8 = from.toUtf8();
  QByteArray to_utf8 = to.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_iconv(threadData, mmc_mk_scon(string_utf8.data()), mmc_mk_scon(from_utf8.data()), mmc_mk_scon(to_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("iconv failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("iconv("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getNthImport(QString class_, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthImport("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthImport(threadData, mmc_mk_scon(class__utf8.data()), index);
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthImport failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getNthImport("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getImportCount(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getImportCount("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getImportCount(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getImportCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getImportCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getNthAnnotationString(QString class_, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthAnnotationString("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthAnnotationString(threadData, mmc_mk_scon(class__utf8.data()), index);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthAnnotationString failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getNthAnnotationString("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getAnnotationCount(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getAnnotationCount("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getAnnotationCount(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAnnotationCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getAnnotationCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getNthInitialEquationItem(QString class_, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthInitialEquationItem("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthInitialEquationItem(threadData, mmc_mk_scon(class__utf8.data()), index);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthInitialEquationItem failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getNthInitialEquationItem("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getInitialEquationItemsCount(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getInitialEquationItemsCount("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getInitialEquationItemsCount(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getInitialEquationItemsCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getInitialEquationItemsCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getNthEquationItem(QString class_, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthEquationItem("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthEquationItem(threadData, mmc_mk_scon(class__utf8.data()), index);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthEquationItem failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getNthEquationItem("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getEquationItemsCount(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getEquationItemsCount("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getEquationItemsCount(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getEquationItemsCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getEquationItemsCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getNthInitialEquation(QString class_, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthInitialEquation("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthInitialEquation(threadData, mmc_mk_scon(class__utf8.data()), index);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthInitialEquation failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getNthInitialEquation("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getInitialEquationCount(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getInitialEquationCount("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getInitialEquationCount(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getInitialEquationCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getInitialEquationCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getNthEquation(QString class_, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthEquation("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthEquation(threadData, mmc_mk_scon(class__utf8.data()), index);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthEquation failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getNthEquation("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getEquationCount(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getEquationCount("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getEquationCount(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getEquationCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getEquationCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getNthInitialAlgorithmItem(QString class_, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthInitialAlgorithmItem("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthInitialAlgorithmItem(threadData, mmc_mk_scon(class__utf8.data()), index);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthInitialAlgorithmItem failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getNthInitialAlgorithmItem("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getInitialAlgorithmItemsCount(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getInitialAlgorithmItemsCount("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getInitialAlgorithmItemsCount(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getInitialAlgorithmItemsCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getInitialAlgorithmItemsCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getNthAlgorithmItem(QString class_, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthAlgorithmItem("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthAlgorithmItem(threadData, mmc_mk_scon(class__utf8.data()), index);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthAlgorithmItem failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getNthAlgorithmItem("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getAlgorithmItemsCount(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getAlgorithmItemsCount("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getAlgorithmItemsCount(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAlgorithmItemsCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getAlgorithmItemsCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getNthInitialAlgorithm(QString class_, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthInitialAlgorithm("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthInitialAlgorithm(threadData, mmc_mk_scon(class__utf8.data()), index);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthInitialAlgorithm failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getNthInitialAlgorithm("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getInitialAlgorithmCount(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getInitialAlgorithmCount("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getInitialAlgorithmCount(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getInitialAlgorithmCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getInitialAlgorithmCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getNthAlgorithm(QString class_, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthAlgorithm("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthAlgorithm(threadData, mmc_mk_scon(class__utf8.data()), index);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthAlgorithm failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getNthAlgorithm("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getAlgorithmCount(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getAlgorithmCount("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getAlgorithmCount(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAlgorithmCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getAlgorithmCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getNthConnection(QString className, modelica_integer index)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(QString::number(index));
  emit logCommand("getNthConnection("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getNthConnection(threadData, mmc_mk_scon(className_utf8.data()), index);
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNthConnection failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getNthConnection("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getConnectionCount(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("getConnectionCount("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getConnectionCount(threadData, mmc_mk_scon(className_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getConnectionCount failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getConnectionCount("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::removeExtendsModifiers(QString className, QString baseClassName, modelica_boolean keepRedeclares)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(baseClassName);
  commandLog.append(",");
  commandLog.append(keepRedeclares ? "true" : "false");
  emit logCommand("removeExtendsModifiers("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray baseClassName_utf8 = baseClassName.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_removeExtendsModifiers(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(baseClassName_utf8.data()), keepRedeclares);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("removeExtendsModifiers failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("removeExtendsModifiers("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::removeComponentModifiers(QString class_, QString componentName, modelica_boolean keepRedeclares)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append("\"" + componentName + "\"");
  commandLog.append(",");
  commandLog.append(keepRedeclares ? "true" : "false");
  emit logCommand("removeComponentModifiers("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QByteArray componentName_utf8 = componentName.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_removeComponentModifiers(threadData, mmc_mk_scon(class__utf8.data()), mmc_mk_scon(componentName_utf8.data()), keepRedeclares);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("removeComponentModifiers failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("removeComponentModifiers("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getInstantiatedParametersAndValues(QString cls)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cls);
  emit logCommand("getInstantiatedParametersAndValues("+commandLog+")", &commandTime);

  QByteArray cls_utf8 = cls.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getInstantiatedParametersAndValues(threadData, mmc_mk_scon(cls_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getInstantiatedParametersAndValues failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getInstantiatedParametersAndValues("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getComponentModifierValues(QString class_, QString modifier)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(modifier);
  emit logCommand("getComponentModifierValues("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QByteArray modifier_utf8 = modifier.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getComponentModifierValues(threadData, mmc_mk_scon(class__utf8.data()), mmc_mk_scon(modifier_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getComponentModifierValues failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getComponentModifierValues("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getComponentModifierValue(QString class_, QString modifier)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(modifier);
  emit logCommand("getComponentModifierValue("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QByteArray modifier_utf8 = modifier.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getComponentModifierValue(threadData, mmc_mk_scon(class__utf8.data()), mmc_mk_scon(modifier_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getComponentModifierValue failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getComponentModifierValue("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getComponentModifierNames(QString class_, QString componentName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append("\"" + componentName + "\"");
  emit logCommand("getComponentModifierNames("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QByteArray componentName_utf8 = componentName.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getComponentModifierNames(threadData, mmc_mk_scon(class__utf8.data()), mmc_mk_scon(componentName_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getComponentModifierNames failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getComponentModifierNames("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getParameterValue(QString class_, QString parameterName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append("\"" + parameterName + "\"");
  emit logCommand("getParameterValue("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QByteArray parameterName_utf8 = parameterName.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getParameterValue(threadData, mmc_mk_scon(class__utf8.data()), mmc_mk_scon(parameterName_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getParameterValue failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getParameterValue("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getParameterNames(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getParameterNames("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getParameterNames(threadData, mmc_mk_scon(class__utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getParameterNames failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getParameterNames("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::closeSimulationResultFile()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("closeSimulationResultFile()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_closeSimulationResultFile(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("closeSimulationResultFile failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("closeSimulationResultFile()", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::checkCodeGraph(QString graphfile, QString codefile)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + graphfile + "\"");
  commandLog.append(",");
  commandLog.append("\"" + codefile + "\"");
  emit logCommand("checkCodeGraph("+commandLog+")", &commandTime);

  QByteArray graphfile_utf8 = graphfile.toUtf8();
  QByteArray codefile_utf8 = codefile.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_checkCodeGraph(threadData, mmc_mk_scon(graphfile_utf8.data()), mmc_mk_scon(codefile_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("checkCodeGraph failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("checkCodeGraph("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::checkTaskGraph(QString filename, QString reffilename)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + filename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + reffilename + "\"");
  emit logCommand("checkTaskGraph("+commandLog+")", &commandTime);

  QByteArray filename_utf8 = filename.toUtf8();
  QByteArray reffilename_utf8 = reffilename.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_checkTaskGraph(threadData, mmc_mk_scon(filename_utf8.data()), mmc_mk_scon(reffilename_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("checkTaskGraph failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("checkTaskGraph("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::diffSimulationResultsHtml(QString var, QString actualFile, QString expectedFile, modelica_real relTol, modelica_real relTolDiffMinMax, modelica_real rangeDelta)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + var + "\"");
  commandLog.append(",");
  commandLog.append("\"" + actualFile + "\"");
  commandLog.append(",");
  commandLog.append("\"" + expectedFile + "\"");
  commandLog.append(",");
  commandLog.append(QString::number(relTol));
  commandLog.append(",");
  commandLog.append(QString::number(relTolDiffMinMax));
  commandLog.append(",");
  commandLog.append(QString::number(rangeDelta));
  emit logCommand("diffSimulationResultsHtml("+commandLog+")", &commandTime);

  QByteArray var_utf8 = var.toUtf8();
  QByteArray actualFile_utf8 = actualFile.toUtf8();
  QByteArray expectedFile_utf8 = expectedFile.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_diffSimulationResultsHtml(threadData, mmc_mk_scon(var_utf8.data()), mmc_mk_scon(actualFile_utf8.data()), mmc_mk_scon(expectedFile_utf8.data()), relTol, relTolDiffMinMax, rangeDelta);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("diffSimulationResultsHtml failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("diffSimulationResultsHtml("+commandLog+")", responseLog, &commandTime);

  return result;
}
OMCInterface::diffSimulationResults_res OMCInterface::diffSimulationResults(QString actualFile, QString expectedFile, QString diffPrefix, modelica_real relTol, modelica_real relTolDiffMinMax, modelica_real rangeDelta, QList<QString > vars, modelica_boolean keepEqualResults)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + actualFile + "\"");
  commandLog.append(",");
  commandLog.append("\"" + expectedFile + "\"");
  commandLog.append(",");
  commandLog.append("\"" + diffPrefix + "\"");
  commandLog.append(",");
  commandLog.append(QString::number(relTol));
  commandLog.append(",");
  commandLog.append(QString::number(relTolDiffMinMax));
  commandLog.append(",");
  commandLog.append(QString::number(rangeDelta));
  commandLog.append(",");
  commandLog.append("{");
  int vars_i = 0;
  foreach(QString vars_elt, vars) {
    if (vars_i) {
      commandLog.append(",");
    }
    commandLog.append("\"" + vars_elt + "\"");
    vars_i++;
  }
  commandLog.append("}");commandLog.append(",");
  commandLog.append(keepEqualResults ? "true" : "false");
  emit logCommand("diffSimulationResults("+commandLog+")", &commandTime);

  QByteArray actualFile_utf8 = actualFile.toUtf8();
  QByteArray expectedFile_utf8 = expectedFile.toUtf8();
  QByteArray diffPrefix_utf8 = diffPrefix.toUtf8();
  void *vars_lst = mmc_mk_nil();
  for (int vars_i = vars.size()-1; vars_i>=0; vars_i--) {
    QString vars_elt = vars[vars_i];
    QByteArray vars_elt_utf8 = vars_elt.toUtf8();
    vars_lst = mmc_mk_cons(mmc_mk_scon(vars_elt_utf8.data()), vars_lst);
  }
  diffSimulationResults_res result;
  void *out2_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result.success = omc_OpenModelicaScriptingAPI_diffSimulationResults(threadData, mmc_mk_scon(actualFile_utf8.data()), mmc_mk_scon(expectedFile_utf8.data()), mmc_mk_scon(diffPrefix_utf8.data()), relTol, relTolDiffMinMax, rangeDelta, vars_lst, keepEqualResults, &out2_mm);
    result.failVars.clear();
    while (!listEmpty(out2_mm)) {
      QString out2_elt;
      out2_elt = MMC_STRINGDATA(MMC_CAR(out2_mm));
      result.failVars.push_back(out2_elt);
      out2_mm = MMC_CDR(out2_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("diffSimulationResults failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("diffSimulationResults("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_real OMCInterface::deltaSimulationResults(QString filename, QString reffilename, QString method, QList<QString > vars)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + filename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + reffilename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + method + "\"");
  commandLog.append(",");
  commandLog.append("{");
  int vars_i = 0;
  foreach(QString vars_elt, vars) {
    if (vars_i) {
      commandLog.append(",");
    }
    commandLog.append("\"" + vars_elt + "\"");
    vars_i++;
  }
  commandLog.append("}");
  emit logCommand("deltaSimulationResults("+commandLog+")", &commandTime);

  QByteArray filename_utf8 = filename.toUtf8();
  QByteArray reffilename_utf8 = reffilename.toUtf8();
  QByteArray method_utf8 = method.toUtf8();
  void *vars_lst = mmc_mk_nil();
  for (int vars_i = vars.size()-1; vars_i>=0; vars_i--) {
    QString vars_elt = vars[vars_i];
    QByteArray vars_elt_utf8 = vars_elt.toUtf8();
    vars_lst = mmc_mk_cons(mmc_mk_scon(vars_elt_utf8.data()), vars_lst);
  }
  modelica_real result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_deltaSimulationResults(threadData, mmc_mk_scon(filename_utf8.data()), mmc_mk_scon(reffilename_utf8.data()), mmc_mk_scon(method_utf8.data()), vars_lst);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("deltaSimulationResults failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("deltaSimulationResults("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::compareSimulationResults(QString filename, QString reffilename, QString logfilename, modelica_real relTol, modelica_real absTol, QList<QString > vars)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + filename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + reffilename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + logfilename + "\"");
  commandLog.append(",");
  commandLog.append(QString::number(relTol));
  commandLog.append(",");
  commandLog.append(QString::number(absTol));
  commandLog.append(",");
  commandLog.append("{");
  int vars_i = 0;
  foreach(QString vars_elt, vars) {
    if (vars_i) {
      commandLog.append(",");
    }
    commandLog.append("\"" + vars_elt + "\"");
    vars_i++;
  }
  commandLog.append("}");
  emit logCommand("compareSimulationResults("+commandLog+")", &commandTime);

  QByteArray filename_utf8 = filename.toUtf8();
  QByteArray reffilename_utf8 = reffilename.toUtf8();
  QByteArray logfilename_utf8 = logfilename.toUtf8();
  void *vars_lst = mmc_mk_nil();
  for (int vars_i = vars.size()-1; vars_i>=0; vars_i--) {
    QString vars_elt = vars[vars_i];
    QByteArray vars_elt_utf8 = vars_elt.toUtf8();
    vars_lst = mmc_mk_cons(mmc_mk_scon(vars_elt_utf8.data()), vars_lst);
  }
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_compareSimulationResults(threadData, mmc_mk_scon(filename_utf8.data()), mmc_mk_scon(reffilename_utf8.data()), mmc_mk_scon(logfilename_utf8.data()), relTol, absTol, vars_lst);
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("compareSimulationResults failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("compareSimulationResults("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::filterSimulationResults(QString inFile, QString outFile, QList<QString > vars, modelica_integer numberOfIntervals, modelica_boolean removeDescription)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + inFile + "\"");
  commandLog.append(",");
  commandLog.append("\"" + outFile + "\"");
  commandLog.append(",");
  commandLog.append("{");
  int vars_i = 0;
  foreach(QString vars_elt, vars) {
    if (vars_i) {
      commandLog.append(",");
    }
    commandLog.append("\"" + vars_elt + "\"");
    vars_i++;
  }
  commandLog.append("}");commandLog.append(",");
  commandLog.append(QString::number(numberOfIntervals));
  commandLog.append(",");
  commandLog.append(removeDescription ? "true" : "false");
  emit logCommand("filterSimulationResults("+commandLog+")", &commandTime);

  QByteArray inFile_utf8 = inFile.toUtf8();
  QByteArray outFile_utf8 = outFile.toUtf8();
  void *vars_lst = mmc_mk_nil();
  for (int vars_i = vars.size()-1; vars_i>=0; vars_i--) {
    QString vars_elt = vars[vars_i];
    QByteArray vars_elt_utf8 = vars_elt.toUtf8();
    vars_lst = mmc_mk_cons(mmc_mk_scon(vars_elt_utf8.data()), vars_lst);
  }
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_filterSimulationResults(threadData, mmc_mk_scon(inFile_utf8.data()), mmc_mk_scon(outFile_utf8.data()), vars_lst, numberOfIntervals, removeDescription);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("filterSimulationResults failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("filterSimulationResults("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::readSimulationResultVars(QString fileName, modelica_boolean readParameters, modelica_boolean openmodelicaStyle)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  commandLog.append(",");
  commandLog.append(readParameters ? "true" : "false");
  commandLog.append(",");
  commandLog.append(openmodelicaStyle ? "true" : "false");
  emit logCommand("readSimulationResultVars("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_readSimulationResultVars(threadData, mmc_mk_scon(fileName_utf8.data()), readParameters, openmodelicaStyle);
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("readSimulationResultVars failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("readSimulationResultVars("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::readSimulationResultSize(QString fileName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  emit logCommand("readSimulationResultSize("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_readSimulationResultSize(threadData, mmc_mk_scon(fileName_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("readSimulationResultSize failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("readSimulationResultSize("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::plotAll(modelica_boolean externalWindow, QString fileName, QString title, QString grid, modelica_boolean logX, modelica_boolean logY, QString xLabel, QString yLabel, QList<modelica_real > xRange, QList<modelica_real > yRange, modelica_real curveWidth, modelica_integer curveStyle, QString legendPosition, QString footer, modelica_boolean autoScale, modelica_boolean forceOMPlot)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(externalWindow ? "true" : "false");
  commandLog.append(",");
  commandLog.append("\"" + fileName + "\"");
  commandLog.append(",");
  commandLog.append("\"" + title + "\"");
  commandLog.append(",");
  commandLog.append("\"" + grid + "\"");
  commandLog.append(",");
  commandLog.append(logX ? "true" : "false");
  commandLog.append(",");
  commandLog.append(logY ? "true" : "false");
  commandLog.append(",");
  commandLog.append("\"" + xLabel + "\"");
  commandLog.append(",");
  commandLog.append("\"" + yLabel + "\"");
  commandLog.append(",");
  commandLog.append("{");
  int xRange_i = 0;
  foreach(modelica_real xRange_elt, xRange) {
    if (xRange_i) {
      commandLog.append(",");
    }
    commandLog.append(QString::number(xRange_elt));
    xRange_i++;
  }
  commandLog.append("}");commandLog.append(",");
  commandLog.append("{");
  int yRange_i = 0;
  foreach(modelica_real yRange_elt, yRange) {
    if (yRange_i) {
      commandLog.append(",");
    }
    commandLog.append(QString::number(yRange_elt));
    yRange_i++;
  }
  commandLog.append("}");commandLog.append(",");
  commandLog.append(QString::number(curveWidth));
  commandLog.append(",");
  commandLog.append(QString::number(curveStyle));
  commandLog.append(",");
  commandLog.append("\"" + legendPosition + "\"");
  commandLog.append(",");
  commandLog.append("\"" + footer + "\"");
  commandLog.append(",");
  commandLog.append(autoScale ? "true" : "false");
  commandLog.append(",");
  commandLog.append(forceOMPlot ? "true" : "false");
  emit logCommand("plotAll("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QByteArray title_utf8 = title.toUtf8();
  QByteArray grid_utf8 = grid.toUtf8();
  QByteArray xLabel_utf8 = xLabel.toUtf8();
  QByteArray yLabel_utf8 = yLabel.toUtf8();
  void *xRange_lst = mmc_mk_nil();
  for (int xRange_i = xRange.size()-1; xRange_i>=0; xRange_i--) {
    modelica_real xRange_elt = xRange[xRange_i];
    xRange_lst = mmc_mk_cons(mmc_mk_rcon(xRange_elt), xRange_lst);
  }
  void *yRange_lst = mmc_mk_nil();
  for (int yRange_i = yRange.size()-1; yRange_i>=0; yRange_i--) {
    modelica_real yRange_elt = yRange[yRange_i];
    yRange_lst = mmc_mk_cons(mmc_mk_rcon(yRange_elt), yRange_lst);
  }
  QByteArray legendPosition_utf8 = legendPosition.toUtf8();
  QByteArray footer_utf8 = footer.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_plotAll(threadData, externalWindow, mmc_mk_scon(fileName_utf8.data()), mmc_mk_scon(title_utf8.data()), mmc_mk_scon(grid_utf8.data()), logX, logY, mmc_mk_scon(xLabel_utf8.data()), mmc_mk_scon(yLabel_utf8.data()), xRange_lst, yRange_lst, curveWidth, curveStyle, mmc_mk_scon(legendPosition_utf8.data()), mmc_mk_scon(footer_utf8.data()), autoScale, forceOMPlot);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("plotAll failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("plotAll("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getPackages(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getPackages("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getPackages(threadData, mmc_mk_scon(class__utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getPackages failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt);
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getPackages("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getUsedClassNames(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("getUsedClassNames("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getUsedClassNames(threadData, mmc_mk_scon(className_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getUsedClassNames failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt);
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getUsedClassNames("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getClassNames(QString class_, modelica_boolean recursive, modelica_boolean qualified, modelica_boolean sort, modelica_boolean builtin, modelica_boolean showProtected, modelica_boolean includeConstants)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append(recursive ? "true" : "false");
  commandLog.append(",");
  commandLog.append(qualified ? "true" : "false");
  commandLog.append(",");
  commandLog.append(sort ? "true" : "false");
  commandLog.append(",");
  commandLog.append(builtin ? "true" : "false");
  commandLog.append(",");
  commandLog.append(showProtected ? "true" : "false");
  commandLog.append(",");
  commandLog.append(includeConstants ? "true" : "false");
  emit logCommand("getClassNames("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getClassNames(threadData, mmc_mk_scon(class__utf8.data()), recursive, qualified, sort, builtin, showProtected, includeConstants);
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getClassNames failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt);
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getClassNames("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setClassComment(QString class_, QString filename)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append("\"" + filename + "\"");
  emit logCommand("setClassComment("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QByteArray filename_utf8 = filename.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setClassComment(threadData, mmc_mk_scon(class__utf8.data()), mmc_mk_scon(filename_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setClassComment failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setClassComment("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::isShortDefinition(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("isShortDefinition("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_isShortDefinition(threadData, mmc_mk_scon(class__utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("isShortDefinition failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("isShortDefinition("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setSourceFile(QString class_, QString filename)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  commandLog.append(",");
  commandLog.append("\"" + filename + "\"");
  emit logCommand("setSourceFile("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QByteArray filename_utf8 = filename.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setSourceFile(threadData, mmc_mk_scon(class__utf8.data()), mmc_mk_scon(filename_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setSourceFile failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setSourceFile("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getSourceFile(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("getSourceFile("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getSourceFile(threadData, mmc_mk_scon(class__utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getSourceFile failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getSourceFile("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::copyClass(QString className, QString newClassName, QString withIn)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append("\"" + newClassName + "\"");
  commandLog.append(",");
  commandLog.append(withIn);
  emit logCommand("copyClass("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray newClassName_utf8 = newClassName.toUtf8();
  QByteArray withIn_utf8 = withIn.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_copyClass(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(newClassName_utf8.data()), mmc_mk_scon(withIn_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("copyClass failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("copyClass("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::moveClassToBottom(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("moveClassToBottom("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_moveClassToBottom(threadData, mmc_mk_scon(className_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("moveClassToBottom failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("moveClassToBottom("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::moveClassToTop(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("moveClassToTop("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_moveClassToTop(threadData, mmc_mk_scon(className_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("moveClassToTop failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("moveClassToTop("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::moveClass(QString className, modelica_integer offset)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(QString::number(offset));
  emit logCommand("moveClass("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_moveClass(threadData, mmc_mk_scon(className_utf8.data()), offset);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("moveClass failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("moveClass("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::reduceTerms(QString className, modelica_real startTime, modelica_real stopTime, modelica_integer numberOfIntervals, modelica_real tolerance, QString method, QString fileNamePrefix, QString options, QString outputFormat, QString variableFilter, QString cflags, QString simflags, QString labelstoCancel)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(QString::number(startTime));
  commandLog.append(",");
  commandLog.append(QString::number(stopTime));
  commandLog.append(",");
  commandLog.append(QString::number(numberOfIntervals));
  commandLog.append(",");
  commandLog.append(QString::number(tolerance));
  commandLog.append(",");
  commandLog.append("\"" + method + "\"");
  commandLog.append(",");
  commandLog.append("\"" + fileNamePrefix + "\"");
  commandLog.append(",");
  commandLog.append("\"" + options + "\"");
  commandLog.append(",");
  commandLog.append("\"" + outputFormat + "\"");
  commandLog.append(",");
  commandLog.append("\"" + variableFilter + "\"");
  commandLog.append(",");
  commandLog.append("\"" + cflags + "\"");
  commandLog.append(",");
  commandLog.append("\"" + simflags + "\"");
  commandLog.append(",");
  commandLog.append("\"" + labelstoCancel + "\"");
  emit logCommand("reduceTerms("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray method_utf8 = method.toUtf8();
  QByteArray fileNamePrefix_utf8 = fileNamePrefix.toUtf8();
  QByteArray options_utf8 = options.toUtf8();
  QByteArray outputFormat_utf8 = outputFormat.toUtf8();
  QByteArray variableFilter_utf8 = variableFilter.toUtf8();
  QByteArray cflags_utf8 = cflags.toUtf8();
  QByteArray simflags_utf8 = simflags.toUtf8();
  QByteArray labelstoCancel_utf8 = labelstoCancel.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_reduceTerms(threadData, mmc_mk_scon(className_utf8.data()), startTime, stopTime, numberOfIntervals, tolerance, mmc_mk_scon(method_utf8.data()), mmc_mk_scon(fileNamePrefix_utf8.data()), mmc_mk_scon(options_utf8.data()), mmc_mk_scon(outputFormat_utf8.data()), mmc_mk_scon(variableFilter_utf8.data()), mmc_mk_scon(cflags_utf8.data()), mmc_mk_scon(simflags_utf8.data()), mmc_mk_scon(labelstoCancel_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("reduceTerms failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("reduceTerms("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::buildLabel(QString className, modelica_real startTime, modelica_real stopTime, modelica_integer numberOfIntervals, modelica_real tolerance, QString method, QString fileNamePrefix, QString options, QString outputFormat, QString variableFilter, QString cflags, QString simflags)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(QString::number(startTime));
  commandLog.append(",");
  commandLog.append(QString::number(stopTime));
  commandLog.append(",");
  commandLog.append(QString::number(numberOfIntervals));
  commandLog.append(",");
  commandLog.append(QString::number(tolerance));
  commandLog.append(",");
  commandLog.append("\"" + method + "\"");
  commandLog.append(",");
  commandLog.append("\"" + fileNamePrefix + "\"");
  commandLog.append(",");
  commandLog.append("\"" + options + "\"");
  commandLog.append(",");
  commandLog.append("\"" + outputFormat + "\"");
  commandLog.append(",");
  commandLog.append("\"" + variableFilter + "\"");
  commandLog.append(",");
  commandLog.append("\"" + cflags + "\"");
  commandLog.append(",");
  commandLog.append("\"" + simflags + "\"");
  emit logCommand("buildLabel("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray method_utf8 = method.toUtf8();
  QByteArray fileNamePrefix_utf8 = fileNamePrefix.toUtf8();
  QByteArray options_utf8 = options.toUtf8();
  QByteArray outputFormat_utf8 = outputFormat.toUtf8();
  QByteArray variableFilter_utf8 = variableFilter.toUtf8();
  QByteArray cflags_utf8 = cflags.toUtf8();
  QByteArray simflags_utf8 = simflags.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_buildLabel(threadData, mmc_mk_scon(className_utf8.data()), startTime, stopTime, numberOfIntervals, tolerance, mmc_mk_scon(method_utf8.data()), mmc_mk_scon(fileNamePrefix_utf8.data()), mmc_mk_scon(options_utf8.data()), mmc_mk_scon(outputFormat_utf8.data()), mmc_mk_scon(variableFilter_utf8.data()), mmc_mk_scon(cflags_utf8.data()), mmc_mk_scon(simflags_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("buildLabel failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("buildLabel("+commandLog+")", responseLog, &commandTime);

  return result;
}
OMCInterface::buildEncryptedPackage_res OMCInterface::buildEncryptedPackage(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("buildEncryptedPackage("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  buildEncryptedPackage_res result;
  void *out2_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result.success = omc_OpenModelicaScriptingAPI_buildEncryptedPackage(threadData, mmc_mk_scon(className_utf8.data()), &out2_mm);
    result.commandOutput = QString::fromUtf8(MMC_STRINGDATA(out2_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("buildEncryptedPackage failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("buildEncryptedPackage("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::buildModelFMU(QString className, QString version, QString fmuType, QString fileNamePrefix, QList<QString > platforms, modelica_boolean includeResources)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append("\"" + version + "\"");
  commandLog.append(",");
  commandLog.append("\"" + fmuType + "\"");
  commandLog.append(",");
  commandLog.append("\"" + fileNamePrefix + "\"");
  commandLog.append(",");
  commandLog.append("{");
  int platforms_i = 0;
  foreach(QString platforms_elt, platforms) {
    if (platforms_i) {
      commandLog.append(",");
    }
    commandLog.append("\"" + platforms_elt + "\"");
    platforms_i++;
  }
  commandLog.append("}");commandLog.append(",");
  commandLog.append(includeResources ? "true" : "false");
  emit logCommand("buildModelFMU("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray version_utf8 = version.toUtf8();
  QByteArray fmuType_utf8 = fmuType.toUtf8();
  QByteArray fileNamePrefix_utf8 = fileNamePrefix.toUtf8();
  void *platforms_lst = mmc_mk_nil();
  for (int platforms_i = platforms.size()-1; platforms_i>=0; platforms_i--) {
    QString platforms_elt = platforms[platforms_i];
    QByteArray platforms_elt_utf8 = platforms_elt.toUtf8();
    platforms_lst = mmc_mk_cons(mmc_mk_scon(platforms_elt_utf8.data()), platforms_lst);
  }
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_buildModelFMU(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(version_utf8.data()), mmc_mk_scon(fmuType_utf8.data()), mmc_mk_scon(fileNamePrefix_utf8.data()), platforms_lst, includeResources);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("buildModelFMU failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("buildModelFMU("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::translateModelFMU(QString className, QString version, QString fmuType, QString fileNamePrefix, modelica_boolean includeResources)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append("\"" + version + "\"");
  commandLog.append(",");
  commandLog.append("\"" + fmuType + "\"");
  commandLog.append(",");
  commandLog.append("\"" + fileNamePrefix + "\"");
  commandLog.append(",");
  commandLog.append(includeResources ? "true" : "false");
  emit logCommand("translateModelFMU("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray version_utf8 = version.toUtf8();
  QByteArray fmuType_utf8 = fmuType.toUtf8();
  QByteArray fileNamePrefix_utf8 = fileNamePrefix.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_translateModelFMU(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(version_utf8.data()), mmc_mk_scon(fmuType_utf8.data()), mmc_mk_scon(fileNamePrefix_utf8.data()), includeResources);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("translateModelFMU failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("translateModelFMU("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::importFMUModelDescription(QString filename, QString workdir, modelica_integer loglevel, modelica_boolean fullPath, modelica_boolean debugLogging, modelica_boolean generateInputConnectors, modelica_boolean generateOutputConnectors)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + filename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + workdir + "\"");
  commandLog.append(",");
  commandLog.append(QString::number(loglevel));
  commandLog.append(",");
  commandLog.append(fullPath ? "true" : "false");
  commandLog.append(",");
  commandLog.append(debugLogging ? "true" : "false");
  commandLog.append(",");
  commandLog.append(generateInputConnectors ? "true" : "false");
  commandLog.append(",");
  commandLog.append(generateOutputConnectors ? "true" : "false");
  emit logCommand("importFMUModelDescription("+commandLog+")", &commandTime);

  QByteArray filename_utf8 = filename.toUtf8();
  QByteArray workdir_utf8 = workdir.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_importFMUModelDescription(threadData, mmc_mk_scon(filename_utf8.data()), mmc_mk_scon(workdir_utf8.data()), loglevel, fullPath, debugLogging, generateInputConnectors, generateOutputConnectors);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("importFMUModelDescription failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("importFMUModelDescription("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::importFMU(QString filename, QString workdir, modelica_integer loglevel, modelica_boolean fullPath, modelica_boolean debugLogging, modelica_boolean generateInputConnectors, modelica_boolean generateOutputConnectors)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + filename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + workdir + "\"");
  commandLog.append(",");
  commandLog.append(QString::number(loglevel));
  commandLog.append(",");
  commandLog.append(fullPath ? "true" : "false");
  commandLog.append(",");
  commandLog.append(debugLogging ? "true" : "false");
  commandLog.append(",");
  commandLog.append(generateInputConnectors ? "true" : "false");
  commandLog.append(",");
  commandLog.append(generateOutputConnectors ? "true" : "false");
  emit logCommand("importFMU("+commandLog+")", &commandTime);

  QByteArray filename_utf8 = filename.toUtf8();
  QByteArray workdir_utf8 = workdir.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_importFMU(threadData, mmc_mk_scon(filename_utf8.data()), mmc_mk_scon(workdir_utf8.data()), loglevel, fullPath, debugLogging, generateInputConnectors, generateOutputConnectors);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("importFMU failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("importFMU("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QList<QString > > OMCInterface::getLoadedLibraries()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getLoadedLibraries()", &commandTime);

  QList<QList<QString > > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getLoadedLibraries(threadData);
    result.clear();
    while (!listEmpty(result_mm)) {
      QList<QString > result_elt;
      result_elt.clear();
      while (!listEmpty(MMC_CAR(result_mm))) {
        QString result_elt_elt;
        result_elt_elt = MMC_STRINGDATA(MMC_CAR(MMC_CAR(result_mm)));
        result_elt.push_back(result_elt_elt);
        MMC_CAR(result_mm) = MMC_CDR(MMC_CAR(result_mm));
      }
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getLoadedLibraries failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QList<QString > result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("{");
    int result_elt_i = 0;
    foreach(QString result_elt_elt, result_elt) {
      if (result_elt_i) {
        responseLog.append(",");
      }
      responseLog.append("\"" + result_elt_elt + "\"");
      result_elt_i++;
    }
    responseLog.append("}");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getLoadedLibraries()", responseLog, &commandTime);

  return result;
}
QString OMCInterface::uriToFilename(QString uri)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + uri + "\"");
  emit logCommand("uriToFilename("+commandLog+")", &commandTime);

  QByteArray uri_utf8 = uri.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_uriToFilename(threadData, mmc_mk_scon(uri_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("uriToFilename failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("uriToFilename("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::rewriteBlockCall(QString className, QString inDefs)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(inDefs);
  emit logCommand("rewriteBlockCall("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray inDefs_utf8 = inDefs.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_rewriteBlockCall(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(inDefs_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("rewriteBlockCall failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("rewriteBlockCall("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::generateVerificationScenarios(QString path)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(path);
  emit logCommand("generateVerificationScenarios("+commandLog+")", &commandTime);

  QByteArray path_utf8 = path.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_generateVerificationScenarios(threadData, mmc_mk_scon(path_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("generateVerificationScenarios failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("generateVerificationScenarios("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::inferBindings(QString path)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(path);
  emit logCommand("inferBindings("+commandLog+")", &commandTime);

  QByteArray path_utf8 = path.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_inferBindings(threadData, mmc_mk_scon(path_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("inferBindings failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("inferBindings("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::exportToFigaro(QString path, QString directory, QString database, QString mode, QString options, QString processor)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(path);
  commandLog.append(",");
  commandLog.append("\"" + directory + "\"");
  commandLog.append(",");
  commandLog.append("\"" + database + "\"");
  commandLog.append(",");
  commandLog.append("\"" + mode + "\"");
  commandLog.append(",");
  commandLog.append("\"" + options + "\"");
  commandLog.append(",");
  commandLog.append("\"" + processor + "\"");
  emit logCommand("exportToFigaro("+commandLog+")", &commandTime);

  QByteArray path_utf8 = path.toUtf8();
  QByteArray directory_utf8 = directory.toUtf8();
  QByteArray database_utf8 = database.toUtf8();
  QByteArray mode_utf8 = mode.toUtf8();
  QByteArray options_utf8 = options.toUtf8();
  QByteArray processor_utf8 = processor.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_exportToFigaro(threadData, mmc_mk_scon(path_utf8.data()), mmc_mk_scon(directory_utf8.data()), mmc_mk_scon(database_utf8.data()), mmc_mk_scon(mode_utf8.data()), mmc_mk_scon(options_utf8.data()), mmc_mk_scon(processor_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("exportToFigaro failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("exportToFigaro("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::listFile(QString class_)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(class_);
  emit logCommand("listFile("+commandLog+")", &commandTime);

  QByteArray class__utf8 = class_.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_listFile(threadData, mmc_mk_scon(class__utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("listFile failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("listFile("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::stringReplace(QString str, QString source, QString target)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + str + "\"");
  commandLog.append(",");
  commandLog.append("\"" + source + "\"");
  commandLog.append(",");
  commandLog.append("\"" + target + "\"");
  emit logCommand("stringReplace("+commandLog+")", &commandTime);

  QByteArray str_utf8 = str.toUtf8();
  QByteArray source_utf8 = source.toUtf8();
  QByteArray target_utf8 = target.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_stringReplace(threadData, mmc_mk_scon(str_utf8.data()), mmc_mk_scon(source_utf8.data()), mmc_mk_scon(target_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("stringReplace failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("stringReplace("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::stringSplit(QString string, QString token)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + string + "\"");
  commandLog.append(",");
  commandLog.append("\"" + token + "\"");
  emit logCommand("stringSplit("+commandLog+")", &commandTime);

  QByteArray string_utf8 = string.toUtf8();
  QByteArray token_utf8 = token.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_stringSplit(threadData, mmc_mk_scon(string_utf8.data()), mmc_mk_scon(token_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("stringSplit failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("stringSplit("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::strtok(QString string, QString token)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + string + "\"");
  commandLog.append(",");
  commandLog.append("\"" + token + "\"");
  emit logCommand("strtok("+commandLog+")", &commandTime);

  QByteArray string_utf8 = string.toUtf8();
  QByteArray token_utf8 = token.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_strtok(threadData, mmc_mk_scon(string_utf8.data()), mmc_mk_scon(token_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("strtok failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("strtok("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::listVariables()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("listVariables()", &commandTime);

  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_listVariables(threadData);
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("listVariables failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt);
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("listVariables()", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getDerivedUnits(QString baseUnit)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + baseUnit + "\"");
  emit logCommand("getDerivedUnits("+commandLog+")", &commandTime);

  QByteArray baseUnit_utf8 = baseUnit.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getDerivedUnits(threadData, mmc_mk_scon(baseUnit_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getDerivedUnits failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getDerivedUnits("+commandLog+")", responseLog, &commandTime);

  return result;
}
OMCInterface::convertUnits_res OMCInterface::convertUnits(QString s1, QString s2)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + s1 + "\"");
  commandLog.append(",");
  commandLog.append("\"" + s2 + "\"");
  emit logCommand("convertUnits("+commandLog+")", &commandTime);

  QByteArray s1_utf8 = s1.toUtf8();
  QByteArray s2_utf8 = s2.toUtf8();
  convertUnits_res result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result.unitsCompatible = omc_OpenModelicaScriptingAPI_convertUnits(threadData, mmc_mk_scon(s1_utf8.data()), mmc_mk_scon(s2_utf8.data()), &result.scaleFactor, &result.offset);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("convertUnits failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("convertUnits("+commandLog+")", responseLog, &commandTime);

  return result;
}
OMCInterface::createXML2RTE_res OMCInterface::createXML2RTE(QString className, QString rewriteRulesFile)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append("\"" + rewriteRulesFile + "\"");
  emit logCommand("createXML2RTE("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray rewriteRulesFile_utf8 = rewriteRulesFile.toUtf8();
  createXML2RTE_res result;
  void *out2_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result.success = omc_OpenModelicaScriptingAPI_createXML2RTE(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(rewriteRulesFile_utf8.data()), &out2_mm);
    result.xmlfileName = QString::fromUtf8(MMC_STRINGDATA(out2_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("createXML2RTE failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("createXML2RTE("+commandLog+")", responseLog, &commandTime);

  return result;
}
OMCInterface::dumpXMLDAE_res OMCInterface::dumpXMLDAE(QString className, QString translationLevel, modelica_boolean addOriginalIncidenceMatrix, modelica_boolean addSolvingInfo, modelica_boolean addMathMLCode, modelica_boolean dumpResiduals, QString fileNamePrefix, QString rewriteRulesFile)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append("\"" + translationLevel + "\"");
  commandLog.append(",");
  commandLog.append(addOriginalIncidenceMatrix ? "true" : "false");
  commandLog.append(",");
  commandLog.append(addSolvingInfo ? "true" : "false");
  commandLog.append(",");
  commandLog.append(addMathMLCode ? "true" : "false");
  commandLog.append(",");
  commandLog.append(dumpResiduals ? "true" : "false");
  commandLog.append(",");
  commandLog.append("\"" + fileNamePrefix + "\"");
  commandLog.append(",");
  commandLog.append("\"" + rewriteRulesFile + "\"");
  emit logCommand("dumpXMLDAE("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray translationLevel_utf8 = translationLevel.toUtf8();
  QByteArray fileNamePrefix_utf8 = fileNamePrefix.toUtf8();
  QByteArray rewriteRulesFile_utf8 = rewriteRulesFile.toUtf8();
  dumpXMLDAE_res result;
  void *out2_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result.success = omc_OpenModelicaScriptingAPI_dumpXMLDAE(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(translationLevel_utf8.data()), addOriginalIncidenceMatrix, addSolvingInfo, addMathMLCode, dumpResiduals, mmc_mk_scon(fileNamePrefix_utf8.data()), mmc_mk_scon(rewriteRulesFile_utf8.data()), &out2_mm);
    result.xmlfileName = QString::fromUtf8(MMC_STRINGDATA(out2_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("dumpXMLDAE failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("dumpXMLDAE("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::translateGraphics(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("translateGraphics("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_translateGraphics(threadData, mmc_mk_scon(className_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("translateGraphics failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("translateGraphics("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::save(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("save("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_save(threadData, mmc_mk_scon(className_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("save failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("save("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::saveTotalModel(QString fileName, QString className, modelica_boolean stripAnnotations, modelica_boolean stripComments)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  commandLog.append(",");
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(stripAnnotations ? "true" : "false");
  commandLog.append(",");
  commandLog.append(stripComments ? "true" : "false");
  emit logCommand("saveTotalModel("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QByteArray className_utf8 = className.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_saveTotalModel(threadData, mmc_mk_scon(fileName_utf8.data()), mmc_mk_scon(className_utf8.data()), stripAnnotations, stripComments);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("saveTotalModel failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("saveTotalModel("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::saveModel(QString fileName, QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  commandLog.append(",");
  commandLog.append(className);
  emit logCommand("saveModel("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QByteArray className_utf8 = className.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_saveModel(threadData, mmc_mk_scon(fileName_utf8.data()), mmc_mk_scon(className_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("saveModel failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("saveModel("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::deleteFile(QString fileName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  emit logCommand("deleteFile("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_deleteFile(threadData, mmc_mk_scon(fileName_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("deleteFile failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("deleteFile("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::loadModel(QString className, QList<QString > priorityVersion, modelica_boolean notify, QString languageStandard, modelica_boolean requireExactVersion)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append("{");
  int priorityVersion_i = 0;
  foreach(QString priorityVersion_elt, priorityVersion) {
    if (priorityVersion_i) {
      commandLog.append(",");
    }
    commandLog.append("\"" + priorityVersion_elt + "\"");
    priorityVersion_i++;
  }
  commandLog.append("}");commandLog.append(",");
  commandLog.append(notify ? "true" : "false");
  commandLog.append(",");
  commandLog.append("\"" + languageStandard + "\"");
  commandLog.append(",");
  commandLog.append(requireExactVersion ? "true" : "false");
  emit logCommand("loadModel("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  void *priorityVersion_lst = mmc_mk_nil();
  for (int priorityVersion_i = priorityVersion.size()-1; priorityVersion_i>=0; priorityVersion_i--) {
    QString priorityVersion_elt = priorityVersion[priorityVersion_i];
    QByteArray priorityVersion_elt_utf8 = priorityVersion_elt.toUtf8();
    priorityVersion_lst = mmc_mk_cons(mmc_mk_scon(priorityVersion_elt_utf8.data()), priorityVersion_lst);
  }
  QByteArray languageStandard_utf8 = languageStandard.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_loadModel(threadData, mmc_mk_scon(className_utf8.data()), priorityVersion_lst, notify, mmc_mk_scon(languageStandard_utf8.data()), requireExactVersion);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("loadModel failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("loadModel("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::generateCode(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("generateCode("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_generateCode(threadData, mmc_mk_scon(className_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("generateCode failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("generateCode("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::runOpenTURNSPythonScript(QString pythonScriptFile)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + pythonScriptFile + "\"");
  emit logCommand("runOpenTURNSPythonScript("+commandLog+")", &commandTime);

  QByteArray pythonScriptFile_utf8 = pythonScriptFile.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_runOpenTURNSPythonScript(threadData, mmc_mk_scon(pythonScriptFile_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("runOpenTURNSPythonScript failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("runOpenTURNSPythonScript("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::buildOpenTURNSInterface(QString className, QString pythonTemplateFile, modelica_boolean showFlatModelica)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append("\"" + pythonTemplateFile + "\"");
  commandLog.append(",");
  commandLog.append(showFlatModelica ? "true" : "false");
  emit logCommand("buildOpenTURNSInterface("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QByteArray pythonTemplateFile_utf8 = pythonTemplateFile.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_buildOpenTURNSInterface(threadData, mmc_mk_scon(className_utf8.data()), mmc_mk_scon(pythonTemplateFile_utf8.data()), showFlatModelica);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("buildOpenTURNSInterface failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("buildOpenTURNSInterface("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::instantiateModel(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("instantiateModel("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_instantiateModel(threadData, mmc_mk_scon(className_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("instantiateModel failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("instantiateModel("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::checkAllModelsRecursive(QString className, modelica_boolean checkProtected)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(checkProtected ? "true" : "false");
  emit logCommand("checkAllModelsRecursive("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_checkAllModelsRecursive(threadData, mmc_mk_scon(className_utf8.data()), checkProtected);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("checkAllModelsRecursive failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("checkAllModelsRecursive("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::checkModel(QString className)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  emit logCommand("checkModel("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_checkModel(threadData, mmc_mk_scon(className_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("checkModel failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("checkModel("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::remove(QString path)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + path + "\"");
  emit logCommand("remove("+commandLog+")", &commandTime);

  QByteArray path_utf8 = path.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_remove(threadData, mmc_mk_scon(path_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("remove failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("remove("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::copy(QString source, QString destination)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + source + "\"");
  commandLog.append(",");
  commandLog.append("\"" + destination + "\"");
  emit logCommand("copy("+commandLog+")", &commandTime);

  QByteArray source_utf8 = source.toUtf8();
  QByteArray destination_utf8 = destination.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_copy(threadData, mmc_mk_scon(source_utf8.data()), mmc_mk_scon(destination_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("copy failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("copy("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::mkdir(QString newDirectory)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + newDirectory + "\"");
  emit logCommand("mkdir("+commandLog+")", &commandTime);

  QByteArray newDirectory_utf8 = newDirectory.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_mkdir(threadData, mmc_mk_scon(newDirectory_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("mkdir failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("mkdir("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::cd(QString newWorkingDirectory)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + newWorkingDirectory + "\"");
  emit logCommand("cd("+commandLog+")", &commandTime);

  QByteArray newWorkingDirectory_utf8 = newWorkingDirectory.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_cd(threadData, mmc_mk_scon(newWorkingDirectory_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("cd failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("cd("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getAstAsCorbaString(QString fileName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  emit logCommand("getAstAsCorbaString("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getAstAsCorbaString(threadData, mmc_mk_scon(fileName_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAstAsCorbaString failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getAstAsCorbaString("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getLanguageStandard()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getLanguageStandard()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getLanguageStandard(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getLanguageStandard failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getLanguageStandard()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::getOrderConnections()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getOrderConnections()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getOrderConnections(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getOrderConnections failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("getOrderConnections()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::getShowAnnotations()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getShowAnnotations()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getShowAnnotations(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getShowAnnotations failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("getShowAnnotations()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setShowAnnotations(modelica_boolean show)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(show ? "true" : "false");
  emit logCommand("setShowAnnotations("+commandLog+")", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setShowAnnotations(threadData, show);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setShowAnnotations failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setShowAnnotations("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getDefaultOpenCLDevice()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getDefaultOpenCLDevice()", &commandTime);

  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getDefaultOpenCLDevice(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getDefaultOpenCLDevice failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getDefaultOpenCLDevice()", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::getVectorizationLimit()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getVectorizationLimit()", &commandTime);

  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getVectorizationLimit(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getVectorizationLimit failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("getVectorizationLimit()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setNoSimplify(modelica_boolean noSimplify)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(noSimplify ? "true" : "false");
  emit logCommand("setNoSimplify("+commandLog+")", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setNoSimplify(threadData, noSimplify);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setNoSimplify failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setNoSimplify("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::getNoSimplify()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getNoSimplify()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_getNoSimplify(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getNoSimplify failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("getNoSimplify()", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getAnnotationVersion()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getAnnotationVersion()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getAnnotationVersion(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAnnotationVersion failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getAnnotationVersion()", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getClassesInModelicaPath()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getClassesInModelicaPath()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getClassesInModelicaPath(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getClassesInModelicaPath failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getClassesInModelicaPath()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::echo(modelica_boolean setEcho)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(setEcho ? "true" : "false");
  emit logCommand("echo("+commandLog+")", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_echo(threadData, setEcho);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("echo failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("echo("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::runScript(QString fileName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  emit logCommand("runScript("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_runScript(threadData, mmc_mk_scon(fileName_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("runScript failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("runScript("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::clearMessages()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("clearMessages()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_clearMessages(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("clearMessages failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("clearMessages()", responseLog, &commandTime);

  return result;
}
OMCInterface::countMessages_res OMCInterface::countMessages()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("countMessages()", &commandTime);

  countMessages_res result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result.numMessages = omc_OpenModelicaScriptingAPI_countMessages(threadData, &result.numErrors, &result.numWarnings);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("countMessages failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("countMessages()", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getMessagesString()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getMessagesString()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getMessagesString(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getMessagesString failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getMessagesString()", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getErrorString(modelica_boolean warningsAsErrors)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(warningsAsErrors ? "true" : "false");
  emit logCommand("getErrorString("+commandLog+")", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getErrorString(threadData, warningsAsErrors);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getErrorString failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getErrorString("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::readFileNoNumeric(QString fileName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  emit logCommand("readFileNoNumeric("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_readFileNoNumeric(threadData, mmc_mk_scon(fileName_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("readFileNoNumeric failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("readFileNoNumeric("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::alarm(modelica_integer seconds)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(QString::number(seconds));
  emit logCommand("alarm("+commandLog+")", &commandTime);

  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_alarm(threadData, seconds);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("alarm failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("alarm("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::compareFiles(QString file1, QString file2)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + file1 + "\"");
  commandLog.append(",");
  commandLog.append("\"" + file2 + "\"");
  emit logCommand("compareFiles("+commandLog+")", &commandTime);

  QByteArray file1_utf8 = file1.toUtf8();
  QByteArray file2_utf8 = file2.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_compareFiles(threadData, mmc_mk_scon(file1_utf8.data()), mmc_mk_scon(file2_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("compareFiles failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("compareFiles("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::compareFilesAndMove(QString newFile, QString oldFile)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + newFile + "\"");
  commandLog.append(",");
  commandLog.append("\"" + oldFile + "\"");
  emit logCommand("compareFilesAndMove("+commandLog+")", &commandTime);

  QByteArray newFile_utf8 = newFile.toUtf8();
  QByteArray oldFile_utf8 = oldFile.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_compareFilesAndMove(threadData, mmc_mk_scon(newFile_utf8.data()), mmc_mk_scon(oldFile_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("compareFilesAndMove failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("compareFilesAndMove("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::writeFile(QString fileName, QString data, modelica_boolean append)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  commandLog.append(",");
  commandLog.append("\"" + data + "\"");
  commandLog.append(",");
  commandLog.append(append ? "true" : "false");
  emit logCommand("writeFile("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QByteArray data_utf8 = data.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_writeFile(threadData, mmc_mk_scon(fileName_utf8.data()), mmc_mk_scon(data_utf8.data()), append);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("writeFile failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("writeFile("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::readFile(QString fileName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  emit logCommand("readFile("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_readFile(threadData, mmc_mk_scon(fileName_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("readFile failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("readFile("+commandLog+")", responseLog, &commandTime);

  return result;
}
OMCInterface::stat_res OMCInterface::stat(QString fileName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  emit logCommand("stat("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  stat_res result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result.success = omc_OpenModelicaScriptingAPI_stat(threadData, mmc_mk_scon(fileName_utf8.data()), &result.fileSize, &result.mtime);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("stat failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("stat("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getVersion(QString cl)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(cl);
  emit logCommand("getVersion("+commandLog+")", &commandTime);

  QByteArray cl_utf8 = cl.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getVersion(threadData, mmc_mk_scon(cl_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getVersion failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getVersion("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::clearCommandLineOptions()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("clearCommandLineOptions()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_clearCommandLineOptions(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("clearCommandLineOptions failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("clearCommandLineOptions()", responseLog, &commandTime);

  return result;
}
OMCInterface::getConfigFlagValidOptions_res OMCInterface::getConfigFlagValidOptions(QString flag)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + flag + "\"");
  emit logCommand("getConfigFlagValidOptions("+commandLog+")", &commandTime);

  QByteArray flag_utf8 = flag.toUtf8();
  getConfigFlagValidOptions_res result;
  void *out1_mm = NULL;
  void *out2_mm = NULL;
  void *out3_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    out1_mm = omc_OpenModelicaScriptingAPI_getConfigFlagValidOptions(threadData, mmc_mk_scon(flag_utf8.data()), &out2_mm, &out3_mm);
    result.validOptions.clear();
    while (!listEmpty(out1_mm)) {
      QString out1_elt;
      out1_elt = MMC_STRINGDATA(MMC_CAR(out1_mm));
      result.validOptions.push_back(out1_elt);
      out1_mm = MMC_CDR(out1_mm);
    }
    result.mainDescription = QString::fromUtf8(MMC_STRINGDATA(out2_mm));
    result.descriptions.clear();
    while (!listEmpty(out3_mm)) {
      QString out3_elt;
      out3_elt = MMC_STRINGDATA(MMC_CAR(out3_mm));
      result.descriptions.push_back(out3_elt);
      out3_mm = MMC_CDR(out3_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getConfigFlagValidOptions failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("getConfigFlagValidOptions("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::getCommandLineOptions()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getCommandLineOptions()", &commandTime);

  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getCommandLineOptions(threadData);
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getCommandLineOptions failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("getCommandLineOptions()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setCommandLineOptions(QString option)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + option + "\"");
  emit logCommand("setCommandLineOptions("+commandLog+")", &commandTime);

  QByteArray option_utf8 = option.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setCommandLineOptions(threadData, mmc_mk_scon(option_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setCommandLineOptions failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setCommandLineOptions("+commandLog+")", responseLog, &commandTime);

  return result;
}
OMCInterface::getAvailableTearingMethods_res OMCInterface::getAvailableTearingMethods()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getAvailableTearingMethods()", &commandTime);

  getAvailableTearingMethods_res result;
  void *out1_mm = NULL;
  void *out2_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    out1_mm = omc_OpenModelicaScriptingAPI_getAvailableTearingMethods(threadData, &out2_mm);
    result.allChoices.clear();
    while (!listEmpty(out1_mm)) {
      QString out1_elt;
      out1_elt = MMC_STRINGDATA(MMC_CAR(out1_mm));
      result.allChoices.push_back(out1_elt);
      out1_mm = MMC_CDR(out1_mm);
    }
    result.allComments.clear();
    while (!listEmpty(out2_mm)) {
      QString out2_elt;
      out2_elt = MMC_STRINGDATA(MMC_CAR(out2_mm));
      result.allComments.push_back(out2_elt);
      out2_mm = MMC_CDR(out2_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAvailableTearingMethods failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("getAvailableTearingMethods()", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getTearingMethod()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getTearingMethod()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getTearingMethod(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getTearingMethod failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getTearingMethod()", responseLog, &commandTime);

  return result;
}
OMCInterface::getAvailableIndexReductionMethods_res OMCInterface::getAvailableIndexReductionMethods()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getAvailableIndexReductionMethods()", &commandTime);

  getAvailableIndexReductionMethods_res result;
  void *out1_mm = NULL;
  void *out2_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    out1_mm = omc_OpenModelicaScriptingAPI_getAvailableIndexReductionMethods(threadData, &out2_mm);
    result.allChoices.clear();
    while (!listEmpty(out1_mm)) {
      QString out1_elt;
      out1_elt = MMC_STRINGDATA(MMC_CAR(out1_mm));
      result.allChoices.push_back(out1_elt);
      out1_mm = MMC_CDR(out1_mm);
    }
    result.allComments.clear();
    while (!listEmpty(out2_mm)) {
      QString out2_elt;
      out2_elt = MMC_STRINGDATA(MMC_CAR(out2_mm));
      result.allComments.push_back(out2_elt);
      out2_mm = MMC_CDR(out2_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAvailableIndexReductionMethods failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("getAvailableIndexReductionMethods()", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getIndexReductionMethod()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getIndexReductionMethod()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getIndexReductionMethod(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getIndexReductionMethod failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getIndexReductionMethod()", responseLog, &commandTime);

  return result;
}
OMCInterface::getAvailableMatchingAlgorithms_res OMCInterface::getAvailableMatchingAlgorithms()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getAvailableMatchingAlgorithms()", &commandTime);

  getAvailableMatchingAlgorithms_res result;
  void *out1_mm = NULL;
  void *out2_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    out1_mm = omc_OpenModelicaScriptingAPI_getAvailableMatchingAlgorithms(threadData, &out2_mm);
    result.allChoices.clear();
    while (!listEmpty(out1_mm)) {
      QString out1_elt;
      out1_elt = MMC_STRINGDATA(MMC_CAR(out1_mm));
      result.allChoices.push_back(out1_elt);
      out1_mm = MMC_CDR(out1_mm);
    }
    result.allComments.clear();
    while (!listEmpty(out2_mm)) {
      QString out2_elt;
      out2_elt = MMC_STRINGDATA(MMC_CAR(out2_mm));
      result.allComments.push_back(out2_elt);
      out2_mm = MMC_CDR(out2_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getAvailableMatchingAlgorithms failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result.toString());
  emit logResponse("getAvailableMatchingAlgorithms()", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getMatchingAlgorithm()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getMatchingAlgorithm()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getMatchingAlgorithm(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getMatchingAlgorithm failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getMatchingAlgorithm()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::clearDebugFlags()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("clearDebugFlags()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_clearDebugFlags(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("clearDebugFlags failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("clearDebugFlags()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setCompilerFlags(QString compilerFlags)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + compilerFlags + "\"");
  emit logCommand("setCompilerFlags("+commandLog+")", &commandTime);

  QByteArray compilerFlags_utf8 = compilerFlags.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setCompilerFlags(threadData, mmc_mk_scon(compilerFlags_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setCompilerFlags failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setCompilerFlags("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getModelicaPath()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getModelicaPath()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getModelicaPath(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getModelicaPath failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getModelicaPath()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setModelicaPath(QString modelicaPath)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + modelicaPath + "\"");
  emit logCommand("setModelicaPath("+commandLog+")", &commandTime);

  QByteArray modelicaPath_utf8 = modelicaPath.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setModelicaPath(threadData, mmc_mk_scon(modelicaPath_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setModelicaPath failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setModelicaPath("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getInstallationDirectoryPath()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getInstallationDirectoryPath()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getInstallationDirectoryPath(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getInstallationDirectoryPath failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getInstallationDirectoryPath()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setInstallationDirectoryPath(QString installationDirectoryPath)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + installationDirectoryPath + "\"");
  emit logCommand("setInstallationDirectoryPath("+commandLog+")", &commandTime);

  QByteArray installationDirectoryPath_utf8 = installationDirectoryPath.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setInstallationDirectoryPath(threadData, mmc_mk_scon(installationDirectoryPath_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setInstallationDirectoryPath failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setInstallationDirectoryPath("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setEnvironmentVar(QString var, QString value)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + var + "\"");
  commandLog.append(",");
  commandLog.append("\"" + value + "\"");
  emit logCommand("setEnvironmentVar("+commandLog+")", &commandTime);

  QByteArray var_utf8 = var.toUtf8();
  QByteArray value_utf8 = value.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setEnvironmentVar(threadData, mmc_mk_scon(var_utf8.data()), mmc_mk_scon(value_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setEnvironmentVar failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setEnvironmentVar("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getEnvironmentVar(QString var)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + var + "\"");
  emit logCommand("getEnvironmentVar("+commandLog+")", &commandTime);

  QByteArray var_utf8 = var.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getEnvironmentVar(threadData, mmc_mk_scon(var_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getEnvironmentVar failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getEnvironmentVar("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getTempDirectoryPath()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getTempDirectoryPath()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getTempDirectoryPath(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getTempDirectoryPath failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getTempDirectoryPath()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setTempDirectoryPath(QString tempDirectoryPath)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + tempDirectoryPath + "\"");
  emit logCommand("setTempDirectoryPath("+commandLog+")", &commandTime);

  QByteArray tempDirectoryPath_utf8 = tempDirectoryPath.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setTempDirectoryPath(threadData, mmc_mk_scon(tempDirectoryPath_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setTempDirectoryPath failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setTempDirectoryPath("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setPlotCommand(QString plotCommand)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + plotCommand + "\"");
  emit logCommand("setPlotCommand("+commandLog+")", &commandTime);

  QByteArray plotCommand_utf8 = plotCommand.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setPlotCommand(threadData, mmc_mk_scon(plotCommand_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setPlotCommand failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setPlotCommand("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setCompileCommand(QString compileCommand)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + compileCommand + "\"");
  emit logCommand("setCompileCommand("+commandLog+")", &commandTime);

  QByteArray compileCommand_utf8 = compileCommand.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setCompileCommand(threadData, mmc_mk_scon(compileCommand_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setCompileCommand failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setCompileCommand("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getCompileCommand()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getCompileCommand()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getCompileCommand(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getCompileCommand failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getCompileCommand()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setCompilerPath(QString compilerPath)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + compilerPath + "\"");
  emit logCommand("setCompilerPath("+commandLog+")", &commandTime);

  QByteArray compilerPath_utf8 = compilerPath.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setCompilerPath(threadData, mmc_mk_scon(compilerPath_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setCompilerPath failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setCompilerPath("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::verifyCompiler()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("verifyCompiler()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_verifyCompiler(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("verifyCompiler failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("verifyCompiler()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setCXXCompiler(QString compiler)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + compiler + "\"");
  emit logCommand("setCXXCompiler("+commandLog+")", &commandTime);

  QByteArray compiler_utf8 = compiler.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setCXXCompiler(threadData, mmc_mk_scon(compiler_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setCXXCompiler failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setCXXCompiler("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getCXXCompiler()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getCXXCompiler()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getCXXCompiler(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getCXXCompiler failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getCXXCompiler()", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getCFlags()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getCFlags()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getCFlags(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getCFlags failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getCFlags()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setCFlags(QString inString)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + inString + "\"");
  emit logCommand("setCFlags("+commandLog+")", &commandTime);

  QByteArray inString_utf8 = inString.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setCFlags(threadData, mmc_mk_scon(inString_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setCFlags failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setCFlags("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setCompiler(QString compiler)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + compiler + "\"");
  emit logCommand("setCompiler("+commandLog+")", &commandTime);

  QByteArray compiler_utf8 = compiler.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setCompiler(threadData, mmc_mk_scon(compiler_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setCompiler failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setCompiler("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getCompiler()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getCompiler()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getCompiler(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getCompiler failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getCompiler()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setLinkerFlags(QString linkerFlags)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + linkerFlags + "\"");
  emit logCommand("setLinkerFlags("+commandLog+")", &commandTime);

  QByteArray linkerFlags_utf8 = linkerFlags.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setLinkerFlags(threadData, mmc_mk_scon(linkerFlags_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setLinkerFlags failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setLinkerFlags("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getLinkerFlags()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getLinkerFlags()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getLinkerFlags(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getLinkerFlags failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getLinkerFlags()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::setLinker(QString linker)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + linker + "\"");
  emit logCommand("setLinker("+commandLog+")", &commandTime);

  QByteArray linker_utf8 = linker.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_setLinker(threadData, mmc_mk_scon(linker_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("setLinker failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("setLinker("+commandLog+")", responseLog, &commandTime);

  return result;
}
QString OMCInterface::getLinker()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("getLinker()", &commandTime);

  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_getLinker(threadData);
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("getLinker failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("getLinker()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::generateSeparateCodeDependenciesMakefile(QString filename, QString directory, QString suffix)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + filename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + directory + "\"");
  commandLog.append(",");
  commandLog.append("\"" + suffix + "\"");
  emit logCommand("generateSeparateCodeDependenciesMakefile("+commandLog+")", &commandTime);

  QByteArray filename_utf8 = filename.toUtf8();
  QByteArray directory_utf8 = directory.toUtf8();
  QByteArray suffix_utf8 = suffix.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_generateSeparateCodeDependenciesMakefile(threadData, mmc_mk_scon(filename_utf8.data()), mmc_mk_scon(directory_utf8.data()), mmc_mk_scon(suffix_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("generateSeparateCodeDependenciesMakefile failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("generateSeparateCodeDependenciesMakefile("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::generateSeparateCodeDependencies(QString stampSuffix)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + stampSuffix + "\"");
  emit logCommand("generateSeparateCodeDependencies("+commandLog+")", &commandTime);

  QByteArray stampSuffix_utf8 = stampSuffix.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_generateSeparateCodeDependencies(threadData, mmc_mk_scon(stampSuffix_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("generateSeparateCodeDependencies failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append("\"" + result_elt + "\"");
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("generateSeparateCodeDependencies("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::generateSeparateCode(QString className, modelica_boolean cleanCache)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(className);
  commandLog.append(",");
  commandLog.append(cleanCache ? "true" : "false");
  emit logCommand("generateSeparateCode("+commandLog+")", &commandTime);

  QByteArray className_utf8 = className.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_generateSeparateCode(threadData, mmc_mk_scon(className_utf8.data()), cleanCache);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("generateSeparateCode failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("generateSeparateCode("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::generateHeader(QString fileName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  emit logCommand("generateHeader("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_generateHeader(threadData, mmc_mk_scon(fileName_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("generateHeader failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("generateHeader("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::clearVariables()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("clearVariables()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_clearVariables(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("clearVariables failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("clearVariables()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::clearProgram()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("clearProgram()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_clearProgram(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("clearProgram failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("clearProgram()", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::clear()
{
  QTime commandTime;
  commandTime.start();
  emit logCommand("clear()", &commandTime);

  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_clear(threadData);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("clear failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("clear()", responseLog, &commandTime);

  return result;
}
QString OMCInterface::help(QString topic)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + topic + "\"");
  emit logCommand("help("+commandLog+")", &commandTime);

  QByteArray topic_utf8 = topic.toUtf8();
  QString result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_help(threadData, mmc_mk_scon(topic_utf8.data()));
    result = QString::fromUtf8(MMC_STRINGDATA(result_mm));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("help failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("\"" + result + "\"");
  emit logResponse("help("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::saveAll(QString fileName)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  emit logCommand("saveAll("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_saveAll(threadData, mmc_mk_scon(fileName_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("saveAll failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("saveAll("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<modelica_integer > OMCInterface::system_parallel(QList<QString > callStr, modelica_integer numThreads)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("{");
  int callStr_i = 0;
  foreach(QString callStr_elt, callStr) {
    if (callStr_i) {
      commandLog.append(",");
    }
    commandLog.append("\"" + callStr_elt + "\"");
    callStr_i++;
  }
  commandLog.append("}");commandLog.append(",");
  commandLog.append(QString::number(numThreads));
  emit logCommand("system__parallel("+commandLog+")", &commandTime);

  void *callStr_lst = mmc_mk_nil();
  for (int callStr_i = callStr.size()-1; callStr_i>=0; callStr_i--) {
    QString callStr_elt = callStr[callStr_i];
    QByteArray callStr_elt_utf8 = callStr_elt.toUtf8();
    callStr_lst = mmc_mk_cons(mmc_mk_scon(callStr_elt_utf8.data()), callStr_lst);
  }
  QList<modelica_integer > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_system__parallel(threadData, callStr_lst, numThreads);
    result.clear();
    while (!listEmpty(result_mm)) {
      modelica_integer result_elt;
      result_elt = mmc_unbox_integer(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("system__parallel failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(modelica_integer result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(QString::number(result_elt));
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("system__parallel("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_integer OMCInterface::system(QString callStr, QString outputFile)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + callStr + "\"");
  commandLog.append(",");
  commandLog.append("\"" + outputFile + "\"");
  emit logCommand("system("+commandLog+")", &commandTime);

  QByteArray callStr_utf8 = callStr.toUtf8();
  QByteArray outputFile_utf8 = outputFile.toUtf8();
  modelica_integer result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_system(threadData, mmc_mk_scon(callStr_utf8.data()), mmc_mk_scon(outputFile_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("system failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(QString::number(result));
  emit logResponse("system("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::loadFileInteractive(QString filename, QString encoding)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + filename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + encoding + "\"");
  emit logCommand("loadFileInteractive("+commandLog+")", &commandTime);

  QByteArray filename_utf8 = filename.toUtf8();
  QByteArray encoding_utf8 = encoding.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_loadFileInteractive(threadData, mmc_mk_scon(filename_utf8.data()), mmc_mk_scon(encoding_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("loadFileInteractive failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt);
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("loadFileInteractive("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::loadFileInteractiveQualified(QString filename, QString encoding)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + filename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + encoding + "\"");
  emit logCommand("loadFileInteractiveQualified("+commandLog+")", &commandTime);

  QByteArray filename_utf8 = filename.toUtf8();
  QByteArray encoding_utf8 = encoding.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_loadFileInteractiveQualified(threadData, mmc_mk_scon(filename_utf8.data()), mmc_mk_scon(encoding_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("loadFileInteractiveQualified failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt);
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("loadFileInteractiveQualified("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::parseFile(QString filename, QString encoding)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + filename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + encoding + "\"");
  emit logCommand("parseFile("+commandLog+")", &commandTime);

  QByteArray filename_utf8 = filename.toUtf8();
  QByteArray encoding_utf8 = encoding.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_parseFile(threadData, mmc_mk_scon(filename_utf8.data()), mmc_mk_scon(encoding_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("parseFile failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt);
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("parseFile("+commandLog+")", responseLog, &commandTime);

  return result;
}
QList<QString > OMCInterface::parseString(QString data, QString filename)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + data + "\"");
  commandLog.append(",");
  commandLog.append("\"" + filename + "\"");
  emit logCommand("parseString("+commandLog+")", &commandTime);

  QByteArray data_utf8 = data.toUtf8();
  QByteArray filename_utf8 = filename.toUtf8();
  QList<QString > result;
  void *result_mm = NULL;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result_mm = omc_OpenModelicaScriptingAPI_parseString(threadData, mmc_mk_scon(data_utf8.data()), mmc_mk_scon(filename_utf8.data()));
    result.clear();
    while (!listEmpty(result_mm)) {
      QString result_elt;
      result_elt = MMC_STRINGDATA(MMC_CAR(result_mm));
      result.push_back(result_elt);
      result_mm = MMC_CDR(result_mm);
    }
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("parseString failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append("{");
  int result_i = 0;
  foreach(QString result_elt, result) {
    if (result_i) {
      responseLog.append(",");
    }
    responseLog.append(result_elt);
    result_i++;
  }
  responseLog.append("}");
  emit logResponse("parseString("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::loadString(QString data, QString filename, QString encoding, modelica_boolean merge)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + data + "\"");
  commandLog.append(",");
  commandLog.append("\"" + filename + "\"");
  commandLog.append(",");
  commandLog.append("\"" + encoding + "\"");
  commandLog.append(",");
  commandLog.append(merge ? "true" : "false");
  emit logCommand("loadString("+commandLog+")", &commandTime);

  QByteArray data_utf8 = data.toUtf8();
  QByteArray filename_utf8 = filename.toUtf8();
  QByteArray encoding_utf8 = encoding.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_loadString(threadData, mmc_mk_scon(data_utf8.data()), mmc_mk_scon(filename_utf8.data()), mmc_mk_scon(encoding_utf8.data()), merge);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("loadString failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("loadString("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::reloadClass(QString name, QString encoding)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append(name);
  commandLog.append(",");
  commandLog.append("\"" + encoding + "\"");
  emit logCommand("reloadClass("+commandLog+")", &commandTime);

  QByteArray name_utf8 = name.toUtf8();
  QByteArray encoding_utf8 = encoding.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_reloadClass(threadData, mmc_mk_scon(name_utf8.data()), mmc_mk_scon(encoding_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("reloadClass failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("reloadClass("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::loadEncryptedPackage(QString fileName, QString workdir)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  commandLog.append(",");
  commandLog.append("\"" + workdir + "\"");
  emit logCommand("loadEncryptedPackage("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QByteArray workdir_utf8 = workdir.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_loadEncryptedPackage(threadData, mmc_mk_scon(fileName_utf8.data()), mmc_mk_scon(workdir_utf8.data()));
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("loadEncryptedPackage failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("loadEncryptedPackage("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::loadFiles(QList<QString > fileNames, QString encoding, modelica_integer numThreads)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("{");
  int fileNames_i = 0;
  foreach(QString fileNames_elt, fileNames) {
    if (fileNames_i) {
      commandLog.append(",");
    }
    commandLog.append("\"" + fileNames_elt + "\"");
    fileNames_i++;
  }
  commandLog.append("}");commandLog.append(",");
  commandLog.append("\"" + encoding + "\"");
  commandLog.append(",");
  commandLog.append(QString::number(numThreads));
  emit logCommand("loadFiles("+commandLog+")", &commandTime);

  void *fileNames_lst = mmc_mk_nil();
  for (int fileNames_i = fileNames.size()-1; fileNames_i>=0; fileNames_i--) {
    QString fileNames_elt = fileNames[fileNames_i];
    QByteArray fileNames_elt_utf8 = fileNames_elt.toUtf8();
    fileNames_lst = mmc_mk_cons(mmc_mk_scon(fileNames_elt_utf8.data()), fileNames_lst);
  }
  QByteArray encoding_utf8 = encoding.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_loadFiles(threadData, fileNames_lst, mmc_mk_scon(encoding_utf8.data()), numThreads);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("loadFiles failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("loadFiles("+commandLog+")", responseLog, &commandTime);

  return result;
}
modelica_boolean OMCInterface::loadFile(QString fileName, QString encoding, modelica_boolean uses)
{
  QTime commandTime;
  commandTime.start();
  QString commandLog;
  commandLog.append("\"" + fileName + "\"");
  commandLog.append(",");
  commandLog.append("\"" + encoding + "\"");
  commandLog.append(",");
  commandLog.append(uses ? "true" : "false");
  emit logCommand("loadFile("+commandLog+")", &commandTime);

  QByteArray fileName_utf8 = fileName.toUtf8();
  QByteArray encoding_utf8 = encoding.toUtf8();
  modelica_boolean result;
  
  try {
    MMC_TRY_TOP_INTERNAL()
  
    result = omc_OpenModelicaScriptingAPI_loadFile(threadData, mmc_mk_scon(fileName_utf8.data()), mmc_mk_scon(encoding_utf8.data()), uses);
    
    MMC_CATCH_TOP()
  } catch(std::exception &exception) {
    emit throwException(QString("loadFile failed. %1").arg(exception.what()));
  }
  
  QString responseLog;
  responseLog.append(result ? "true" : "false");
  emit logResponse("loadFile("+commandLog+")", responseLog, &commandTime);

  return result;
}

#endif /* OpenModelicaScriptingAPIQt__H */